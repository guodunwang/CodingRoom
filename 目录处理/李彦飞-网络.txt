第1章　绪论　　　/　1
1.1　我在工作中的困惑　　　/　2
1.1.1　过多的TIME_WAIT　　　/　2
1.1.2　长连接开销　　　/　2
1.1.3　CPU被消耗光了　　　/　3
1.1.4　为什么不同的语言网络性能差别巨大　　　/　4
1.1.5　访问127.0.0.1过网卡吗　　　/　4
1.1.6　软中断和硬中断　　　/　5
1.1.7　零拷贝到底是怎么回事　　　/　5
1.1.8　DPDK　　　/　5
1.2　本书内容结构　　　/　6
1.3　一些约定　　　/　7
1.4　一些术语　　　/　8

第2章　内核是如何接收网络包的　　　/　9
2.1　相关实际问题　　　/　10
2.2　数据是如何从网卡到协议栈的　　　/　11
2.2.1　Linux网络收包总览　　　/　12
2.2.2　Linux启动　　　/　13
2.2.3　迎接数据的到来　　　/　23
2.2.4　收包小结　　　/　33
2.3　本章总结　　　/　34

第3章　内核是如何与用户进程协作的　　　/　41
3.1　相关实际问题　　　/　42
3.2　socket的直接创建　　　/　43
3.3　内核和用户进程协作之阻塞方式　　　/　46
3.3.1　等待接收消息　　　/　47
3.3.2　软中断模块　　　/　52
3.3.3　同步阻塞总结　　　/　57
3.4　内核和用户进程协作之epoll　　　/　59
3.4.1　epoll内核对象的创建　　　/　60
3.4.2　为epoll添加socket　　　/　62
3.4.3　epoll_wait之等待接收　　　/　68
3.4.4　数据来了　　　/　71
3.4.5　小结　　　/　79
3.5　本章总结　　　/　80

第4章　内核是如何发送网络包的　　　/　84
4.1　相关实际问题　　　/　85
4.2　网络包发送过程总览　　　/　86
4.3　网卡启动准备　　　/　90
4.4　数据从用户进程到网卡的详细过程　　　/　92
4.4.1　send系统调用实现　　　/　92
4.4.2　传输层处理　　　/　94
4.4.3　网络层发送处理　　　/　99
4.4.4　邻居子系统　　　/　103
4.4.5　网络设备子系统　　　/　105
4.4.6　软中断调度　　　/　109
4.4.7　igb网卡驱动发送　　　/　111
4.5　RingBuffer内存回收　　　/　114
4.6　本章总结　　　/　115

第5章　深度理解本机网络IO　　　/　119
5.1　相关实际问题　　　/　120
5.2　跨机网络通信过程　　　/　120
5.2.1　跨机数据发送　　　/　120
5.2.2　跨机数据接收　　　/　125
5.2.3　跨机网络通信汇总　　　/　127
5.3　本机发送过程　　　/　127
5.3.1　网络层路由　　　/　127
5.3.2　本机IP路由　　　/　130
5.3.3　网络设备子系统　　　/　131
5.3.4　“驱动”程序　　　/　133
5.4　本机接收过程　　　/　135
5.5　本章总结　　　/　137

第6章　深度理解TCP连接建立过程　　　/　139
6.1　相关实际问题　　　/　140
6.2　深入理解listen　　　/　141
6.2.1　listen系统调用　　　/　141
6.2.2　协议栈listen　　　/　142
6.2.3　接收队列定义　　　/　143
6.2.4　接收队列申请和初始化　　　/　145
6.2.5　半连接队列长度计算　　　/　146
6.2.6　listen过程小结　　　/　148
6.3　深入理解connect　　　/　148
6.3.1　connect调用链展开　　　/　149
6.3.2　选择可用端口　　　/　151
6.3.3　端口被使用过怎么办　　　/　153
6.3.4　发起syn请求　　　/　155
6.3.5　connect小结　　　/　156
6.4　完整TCP连接建立过程　　　/　157
6.4.1　客户端connect　　　/　159
6.4.2　服务端响应SYN　　　/　160
6.4.3　客户端响应SYNACK　　　/　162
6.4.4　服务端响应ACK　　　/　164
6.4.5　服务端accept　　　/　167
6.4.6　连接建立过程总结　　　/　167
6.5　异常TCP连接建立情况　　　/　169
6.5.1　connect系统调用耗时失控　　　/　169
6.5.2　第一次握手丢包　　　/　171
6.5.3　第三次握手丢包　　　/　176
6.5.4　握手异常总结　　　/　178
6.6　如何查看是否有连接队列溢出发生　　　/　179
6.6.1　全连接队列溢出判断　　　/　179
6.6.2　半连接队列溢出判断　　　/　181
6.6.3　小结　　　/　183
6.7　本章总结　　　/　183

第7章　一条TCP连接消耗多大内存　　　/　187
7.1　相关实际问题　　　/　188
7.2　Linux内核如何管理内存　　　/　188
7.2.1　node划分　　　/　189
7.2.2　zone划分　　　/　191
7.2.3　基于伙伴系统管理空闲页面　　　/　192
7.2.4　slab分配器　　　/　194
7.2.5　小结　　　/　197
7.3　TCP连接相关内核对象　　　/　198
7.3.1　socket函数直接创建　　　/　198
7.3.2　服务端socket创建　　　/　206
7.4　实测TCP内核对象开销　　　/　207
7.4.1　实验准备　　　/　207
7.4.2　实验开始　　　/　208
7.4.3　观察ESTABLISH状态开销　　　/　209
7.4.4　观察非ESTABLISH状态开销　　　/　211
7.4.5　收发缓存区简单测试　　　/　214
7.4.6　实验结果小结　　　/　215
7.5　本章总结　　　/　216

第8章　一台机器最多能支持多少条TCP连接　　　/　218
8.1　相关实际问题　　　/　219
8.2　理解Linux最大文件描述符限制　　　/　219
8.2.1　找到源码入口　　　/　220
8.2.2　寻找进程级限制nofile和fs.nr_open　　　/　221
8.2.3　寻找系统级限制fs.file-max　　　/　223
8.2.4　小结　　　/　224
8.3　一台服务端机器最多可以支撑多少条TCP连接　　　/　225
8.3.1　一次关于服务端并发的聊天　　　/　225
8.3.2　服务器百万连接达成记　　　/　228
8.3.3　小结　　　/　232
8.4　一台客户端机器最多只能发起65 535条连接吗　　　/　232
8.4.1　65 535的束缚　　　/　232
8.4.2　多IP增加连接数　　　/　234
8.4.3　端口复用增加连接数　　　/　236
8.4.4　小结　　　/　243
8.5　单机百万并发连接的动手实验　　　/　243
8.5.1　方案一，多IP客户端发起百万连接　　　/　244
8.5.2　方案二，单IP客户端机器发起百万连接　　　/　248
8.5.3　最后多谈一点　　　/　250
8.6　本章总结　　　/　251

第9章　网络性能优化建议　　　/　253
9.1　网络请求优化　　　/　254
9.2　接收过程优化　　　/　256
9.3　发送过程优化　　　/　262
9.4　内核与进程协作优化　　　/　268
9.5　握手挥手过程优化　　　/　269

第10章　容器网络虚拟化　　　/　272
10.1　相关实际问题　　　/　273
10.2　veth设备对　　　/　274
10.2.1　veth如何使用　　　/　274
10.2.2　veth底层创建过程　　　/　276
10.2.3　veth网络通信过程　　　/　278
10.2.4　小结　　　/　281
10.3　网络命名空间　　　/　281
10.3.1　如何使用网络命名空间　　　/　282
10.3.2　命名空间相关的定义　　　/　284
10.3.3　网络命名空间的创建　　　/　287
10.3.4　网络收发如何使用网络命名空间　　　/　295
10.3.5　结论　　　/　296
10.4　虚拟交换机Bridge　　　/　297
10.4.1　如何使用Bridge　　　/　298
10.4.2　Bridge是如何创建出来的　　　/　301
10.4.3　添加设备　　　/　303
10.4.4　数据包处理过程　　　/　305
10.4.5　小结　　　/　308
10.5　外部网络通信　　　/　310
10.5.1　路由和NAT　　　/　311
10.5.2　实现外部网络通信　　　/　313
10.5.3　小结　　　/　318
10.6　本章总结　　　/　319