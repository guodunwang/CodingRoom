## 第1章 绪论　　　
### 1.1　 我在工作中的困惑　　　
#### 1.1.1　 过多的TIME_WAIT　　　
#### 1.1.2　 长连接开销　　　
#### 1.1.3　 CPU被消耗光了　　　
#### 1.1.4　 为什么不同的语言网络性能差别巨大　　　
#### 1.1.5　 访问127.0.0.1过网卡吗　　　
#### 1.1.6　 软中断和硬中断　　　
#### 1.1.7　 零拷贝到底是怎么回事　　　
#### 1.1.8　 DPDK　　　
### 1.2　 本书内容结构　　　
### 1.3　 一些约定　　　
### 1.4　 一些术语　　　
### 
## 第2章 内核是如何接收网络包的　　　
### 2.1　 相关实际问题　　　
### 2.2　 数据是如何从网卡到协议栈的　　　
#### 2.2.1　 Linux网络收包总览　　　
#### 2.2.2　 Linux启动　　　
#### 2.2.3　 迎接数据的到来　　　
#### 2.2.4　 收包小结　　　
### 2.3　 本章总结　　　
### 
## 第3章 内核是如何与用户进程协作的　　　
### 3.1　 相关实际问题　　　
### 3.2　 socket的直接创建　　　
### 3.3　 内核和用户进程协作之阻塞方式　　　
#### 3.3.1　 等待接收消息　　　
#### 3.3.2　 软中断模块　　　
#### 3.3.3　 同步阻塞总结　　　
### 3.4　 内核和用户进程协作之epoll　　　
#### 3.4.1　 epoll内核对象的创建　　　
#### 3.4.2　 为epoll添加socket　　　
#### 3.4.3　 epoll_wait之等待接收　　　
#### 3.4.4　 数据来了　　　
#### 3.4.5　 小结　　　
### 3.5　 本章总结　　　
### 
## 第4章 内核是如何发送网络包的　　　
### 4.1　 相关实际问题　　　
### 4.2　 网络包发送过程总览　　　
### 4.3　 网卡启动准备　　　
### 4.4　 数据从用户进程到网卡的详细过程　　　
#### 4.4.1　 send系统调用实现　　　
#### 4.4.2　 传输层处理　　　
#### 4.4.3　 网络层发送处理　　　
#### 4.4.4　 邻居子系统　　　
#### 4.4.5　 网络设备子系统　　　
#### 4.4.6　 软中断调度　　　
#### 4.4.7　 igb网卡驱动发送　　　
### 4.5　 RingBuffer内存回收　　　
### 4.6　 本章总结　　　
### 
## 第5章 深度理解本机网络IO　　　
### 5.1　 相关实际问题　　　
### 5.2　 跨机网络通信过程　　　
#### 5.2.1　 跨机数据发送　　　
#### 5.2.2　 跨机数据接收　　　
#### 5.2.3　 跨机网络通信汇总　　　
### 5.3　 本机发送过程　　　
#### 5.3.1　 网络层路由　　　
#### 5.3.2　 本机IP路由　　　
#### 5.3.3　 网络设备子系统　　　
#### 5.3.4　 “驱动”程序　　　
### 5.4　 本机接收过程　　　
### 5.5　 本章总结　　　
### 
## 第6章 深度理解TCP连接建立过程　　　
### 6.1　 相关实际问题　　　
### 6.2　 深入理解listen　　　
#### 6.2.1　 listen系统调用　　　
#### 6.2.2　 协议栈listen　　　
#### 6.2.3　 接收队列定义　　　
#### 6.2.4　 接收队列申请和初始化　　　
#### 6.2.5　 半连接队列长度计算　　　
#### 6.2.6　 listen过程小结　　　
### 6.3　 深入理解connect　　　
#### 6.3.1　 connect调用链展开　　　
#### 6.3.2　 选择可用端口　　　
#### 6.3.3　 端口被使用过怎么办　　　
#### 6.3.4　 发起syn请求　　　
#### 6.3.5　 connect小结　　　
### 6.4　 完整TCP连接建立过程　　　
#### 6.4.1　 客户端connect　　　
#### 6.4.2　 服务端响应SYN　　　
#### 6.4.3　 客户端响应SYNACK　　　
#### 6.4.4　 服务端响应ACK　　　
#### 6.4.5　 服务端accept　　　
#### 6.4.6　 连接建立过程总结　　　
### 6.5　 异常TCP连接建立情况　　　
#### 6.5.1　 connect系统调用耗时失控　　　
#### 6.5.2　 第一次握手丢包　　　
#### 6.5.3　 第三次握手丢包　　　
#### 6.5.4　 握手异常总结　　　
### 6.6　 如何查看是否有连接队列溢出发生　　　
#### 6.6.1　 全连接队列溢出判断　　　
#### 6.6.2　 半连接队列溢出判断　　　
#### 6.6.3　 小结　　　
### 6.7　 本章总结　　　
### 
## 第7章 一条TCP连接消耗多大内存　　　
### 7.1　 相关实际问题　　　
### 7.2　 Linux内核如何管理内存　　　
#### 7.2.1　 node划分　　　
#### 7.2.2　 zone划分　　　
#### 7.2.3　 基于伙伴系统管理空闲页面　　　
#### 7.2.4　 slab分配器　　　
#### 7.2.5　 小结　　　
### 7.3　 TCP连接相关内核对象　　　
#### 7.3.1　 socket函数直接创建　　　
#### 7.3.2　 服务端socket创建　　　
### 7.4　 实测TCP内核对象开销　　　
#### 7.4.1　 实验准备　　　
#### 7.4.2　 实验开始　　　
#### 7.4.3　 观察ESTABLISH状态开销　　　
#### 7.4.4　 观察非ESTABLISH状态开销　　　
#### 7.4.5　 收发缓存区简单测试　　　
#### 7.4.6　 实验结果小结　　　
### 7.5　 本章总结　　　
### 
## 第8章 一台机器最多能支持多少条TCP连接　　　
### 8.1　 相关实际问题　　　
### 8.2　 理解Linux最大文件描述符限制　　　
#### 8.2.1　 找到源码入口　　　
#### 8.2.2　 寻找进程级限制nofile和fs.nr_open　　　
#### 8.2.3　 寻找系统级限制fs.file-max　　　
#### 8.2.4　 小结　　　
### 8.3　 一台服务端机器最多可以支撑多少条TCP连接　　　
#### 8.3.1　 一次关于服务端并发的聊天　　　
#### 8.3.2　 服务器百万连接达成记　　　
#### 8.3.3　 小结　　　
### 8.4　 一台客户端机器最多只能发起65 535条连接吗　　　
#### 8.4.1　 65 535的束缚　　　
#### 8.4.2　 多IP增加连接数　　　
#### 8.4.3　 端口复用增加连接数　　　
#### 8.4.4　 小结　　　
### 8.5　 单机百万并发连接的动手实验　　　
#### 8.5.1　 方案一，多IP客户端发起百万连接　　　
#### 8.5.2　 方案二，单IP客户端机器发起百万连接　　　
#### 8.5.3　 最后多谈一点　　　
### 8.6　 本章总结　　　
### 
## 第9章 网络性能优化建议　　　
### 9.1　 网络请求优化　　　
### 9.2　 接收过程优化　　　
### 9.3　 发送过程优化　　　
### 9.4　 内核与进程协作优化　　　
### 9.5　 握手挥手过程优化　　　
### 
## 第10章 容器网络虚拟化　　　
### 10.1　 相关实际问题　　　
### 10.2　 veth设备对　　　
#### 10.2.1　 veth如何使用　　　
#### 10.2.2　 veth底层创建过程　　　
#### 10.2.3　 veth网络通信过程　　　
#### 10.2.4　 小结　　　
### 10.3　 网络命名空间　　　
#### 10.3.1　 如何使用网络命名空间　　　
#### 10.3.2　 命名空间相关的定义　　　
#### 10.3.3　 网络命名空间的创建　　　
#### 10.3.4　 网络收发如何使用网络命名空间　　　
#### 10.3.5　 结论　　　
### 10.4　 虚拟交换机Bridge　　　
#### 10.4.1　 如何使用Bridge　　　
#### 10.4.2　 Bridge是如何创建出来的　　　
#### 10.4.3　 添加设备　　　
#### 10.4.4　 数据包处理过程　　　
#### 10.4.5　 小结　　　
### 10.5　 外部网络通信　　　
#### 10.5.1　 路由和NAT　　　
#### 10.5.2　 实现外部网络通信　　　
#### 10.5.3　 小结　　　
### 10.6　 本章总结　　　