## 第1章 汇编基础
### 1.1 x86通用寄存器
#### 1.1.132 位架构
#### 1.1.264 位架构
### 1.2 常用汇编指令
#### 1.2.1 整数加减指令
#### 1.2.2 数据传输指令
#### 1.2.3 入栈和出栈指令
#### 1.2.4 分支跳转指令
#### 1.2.5 过程调用指令
### 1.3 内存分页机制
#### 1.3.1 线性地址
#### 1.3.280386 两级页表
#### 1.3.3 PAE三级页表
#### 1.3.4 x64四级页表
#### 1.3.5 虚拟内存
### 1.4 汇编代码风格
### 1.5 本章小结
## 第2章 指针(7min)
### 2.1 指针构成
#### 2.1.1 地址
#### 2.1.2 元素类型
### 2.2 相关操作
#### 2.2.1 取地址
#### 2.2.2 解引用
#### 2.2.3 强制类型转换
#### 2.2.4 指针运算
### 2.3 unsafe包
#### 2.3.1 标准库与keyword
#### 2.3.2 关于uintptr
#### 2.3.3 内存对齐
### 2.4 本章小结
## 第3章 函数(44min)
### 3.1 栈帧
#### 3.1.1 栈帧布局
#### 3.1.2 寻址方式
#### 3.1.3 又见内存对齐
#### 3.1.4 调用约定
#### 3.1.5 Go 1.17的变化
### 3.2 逃逸分析
#### 3.2.1 什么是逃逸分析
#### 3.2.2 不逃逸分析
#### 3.2.3 不逃逸判断
### 3.3 Function Value
#### 3.3.1 函数指针
#### 3.3.2 Function Value分析
#### 3.3.3 闭包
### 3.4 defer
#### 3.4.1 最初的链表
#### 3.4.2 栈上分配
#### 3.4.3 高效的open coded defer
### 3.5 panic
#### 3.5.1 gopanic()函数
#### 3.5.2 gorecover()函数
#### 3.5.3 嵌套的panic
#### 3.5.4 支持open coded defer
### 3.6 本章小结
## 第4章 方法(6min)
### 4.1 接收者类型
#### 4.1.1 值类型
#### 4.1.2 指针类型
#### 4.1.3 包装方法
### 4.2 Method Value
#### 4.2.1 基于类型
#### 4.2.2 基于对象
### 4.3 组合式继承
#### 4.3.1 嵌入值
#### 4.3.2 嵌入指针
#### 4.3.3 多重继承
### 4.4 本章小结
## 第5章 接口(27min)
### 5.1 空接口
#### 5.1.1 一个更好的void*
#### 5.1.2 类型元数据
#### 5.1.3 逃逸与装箱
### 5.2 非空接口
#### 5.2.1 动态派发
#### 5.2.2 具体实现
#### 5.2.3 接收者类型
#### 5.2.4 组合式继承
### 5.3 类型断言
#### 5.3.1 E To 具体类型
#### 5.3.2 E To I
#### 5.3.3 I To 具体类型
#### 5.3.4 I To I
### 5.4 反射
#### 5.4.1 类型系统
#### 5.4.2 类型元数据详细讲解
#### 5.4.3 对数据的操作
#### 5.4.4 对链接器裁剪的影响
### 5.5 本章小结
## 第6章 goroutine(48min)
### 6.1 进程、线程与协程
#### 6.1.1 进程
#### 6.1.2 线程
#### 6.1.3 协程
### 6.2 IO多路复用
#### 6.2.13 种网络IO模型
#### 6.2.2 示例对比
### 6.3 巧妙结合
### 6.4 GMP模型
#### 6.4.1 基本概念
#### 6.4.2 从GM到GMP
### 6.5 GMP主要数据结构
#### 6.5.1 runtime.g
#### 6.5.2 runtime.m
#### 6.5.3 runtime.p
#### 6.5.4 schedt
### 6.6 调度器初始化
#### 6.6.1 调度器初始化过程
#### 6.6.2 runtime.schedinit()函数
### 6.7 G的创建与退出
#### 6.7.1 相关汇编函数
#### 6.7.2 runtime.newproc()函数
### 6.8 调度循环
#### 6.8.1 runtime.schedule()函数
#### 6.8.2 runtime.findrunnable()函数
### 6.9 抢占式调度
#### 6.9.1 Go 1.13的抢占式调度
#### 6.9.2 Go 1.14的抢占式调度
### 6.10 timer
#### 6.10.1 一个示例
#### 6.10.2 数据结构
#### 6.10.3 操作函数
### 6.11 netpoller
#### 6.11.1 跨平台的netpoller
#### 6.11.2 TCP连接的Read()方法
### 6.12 监控线程
#### 6.12.1 按需执行timer和netpoll
#### 6.12.2 抢占G和P
#### 6.12.3 强制执行GC
### 6.13 本章小结
## 第7章 同步(32min)
### 7.1 Happens Before
#### 7.1.1 并发
#### 7.1.2 并行
### 7.2 内存乱序
#### 7.2.1 编译期乱序
#### 7.2.2 执行期乱序
#### 7.2.3 内存排序指令
### 7.3 常见的锁
#### 7.3.1 原子指令
#### 7.3.2 自旋锁
#### 7.3.3 调度器对象
#### 7.3.4 优化的锁
### 7.4 Go语言的同步
#### 7.4.1 runtime.mutex
#### 7.4.2 semaphore
#### 7.4.3 sync.Mutex
#### 7.4.4 channel
### 7.5 本章小结
## 第8章 堆(17min)
### 8.1 内存分配
#### 8.1.1 sizeclasses
#### 8.1.2 heapArena
#### 8.1.3 mspan
#### 8.1.4 mcentral
#### 8.1.5 mcache
#### 8.1.6 mallocgc
### 8.2 垃圾回收
#### 8.2.1 GC root
#### 8.2.2 三色抽象
#### 8.2.3 写屏障
#### 8.2.4 触发方式
#### 8.2.5 GC Worker
#### 8.2.6 gctrace
### 8.3 本章小结
## 第9章 栈(8min)
### 9.1 栈分配
#### 9.1.1 栈分配初始化
#### 9.1.2 栈分配逻辑
### 9.2 栈增长
#### 9.2.1 栈增长检测代码
#### 9.2.2 栈增长函数
### 9.3 栈收缩
### 9.4 栈释放
#### 9.4.1 小于或等于16KB的栈空间
#### 9.4.2 大于或等于32KB的栈空间
#### 9.4.3 栈释放时机
### 9.5 本章小结