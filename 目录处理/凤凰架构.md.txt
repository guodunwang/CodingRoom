# 前言
# 第一部分　演进中的架构
## 第1章 服务架构演进史
### 1.1　 原始分布式时代
### 1.2　 单体系统时代
### 1.3　 SOA时代
### 1.4　 微服务时代
### 1.5　 后微服务时代
### 1.6　 无服务时代
# 第二部分　架构师的视角
## 第2章 访问远程服务
### 2.1　 远程服务调用
#### 2.1.1　 进程间通信
#### 2.1.2　 通信的成本
#### 2.1.3　 三个基本问题
#### 2.1.4　 统一的RPC
#### 2.1.5　 分裂的RPC
### 2.2　 REST设计风格
#### 2.2.1　 理解REST
#### 2.2.2　 RESTful的系统
#### 2.2.3　 RMM
#### 2.2.4　 不足与争议
## 第3章 事务处理
### 3.1　 本地事务
#### 3.1.1　 实现原子性和持久性
#### 3.1.2　 实现隔离性
### 3.2　 全局事务
### 3.3　 共享事务
### 3.4　 分布式事务
#### 3.4.1　 CAP与ACID
#### 3.4.2　 可靠事件队列
#### 3.4.3　 TCC事务
#### 3.4.4　 SAGA事务
## 第4章 透明多级分流系统
### 4.1　 客户端缓存
#### 4.1.1　 强制缓存
#### 4.1.2　 协商缓存
### 4.2　 域名解析
### 4.3　 传输链路
#### 4.3.1　 连接数优化
#### 4.3.2　 传输压缩
#### 4.3.3　 快速UDP网络连接
### 4.4　 内容分发网络
#### 4.4.1　 路由解析
#### 4.4.2　 内容分发
#### 4.4.3　 CDN应用
### 4.5　 负载均衡
#### 4.5.1　 数据链路层负载均衡
#### 4.5.2　 网络层负载均衡
#### 4.5.3　 应用层负载均衡
#### 4.5.4　 均衡策略与实现
### 4.6　 服务端缓存
#### 4.6.1　 缓存属性
#### 4.6.2　 缓存风险
## 第5章 架构安全性
### 5.1　 认证
#### 5.1.1　 认证的标准
#### 5.1.2　 认证的实现
### 5.2　 授权
#### 5.2.1　 RBAC
#### 5.2.2　 OAuth
### 5.3　 凭证
#### 5.3.1　 Cookie-Session
#### 5.3.2　 JWT
### 5.4　 保密
#### 5.4.1　 保密的强度
#### 5.4.2　 客户端加密
#### 5.4.3　 密码存储和验证
### 5.5　 传输
#### 5.5.1　 摘要、加密与签名
#### 5.5.2　 数字证书
#### 5.5.3　 传输安全层
### 5.6　 验证
# 第三部分　分布式的基石
## 第6章 分布式共识
### 6.1　 Paxos
#### 6.1.1　 Paxos的诞生
#### 6.1.2　 算法流程
#### 6.1.3　 工作实例
### 6.2　 Multi Paxos
### 6.3　 Gossip协议
## 第7章 从类库到服务
### 7.1　 服务发现
#### 7.1.1　 服务发现的意义
#### 7.1.2　 可用与可靠
#### 7.1.3　 注册中心实现
### 7.2　 网关路由
#### 7.2.1　 网关的职责
#### 7.2.2　 网络I/O模型
#### 7.2.3　 BFF网关
### 7.3　 客户端负载均衡
#### 7.3.1　 客户端负载均衡器
#### 7.3.2　 代理负载均衡器
#### 7.3.3　 地域与区域
## 第8章 流量治理
### 8.1　 服务容错
#### 8.1.1　 容错策略
#### 8.1.2　 容错设计模式
### 8.2　 流量控制
#### 8.2.1　 流量统计指标
#### 8.2.2　 限流设计模式
#### 8.2.3　 分布式限流
## 第9章 可靠通信
### 9.1　 零信任网络
#### 9.1.1　 零信任安全模型的特征
#### 9.1.2　 Google的实践探索
### 9.2　 服务安全
#### 9.2.1　 建立信任
#### 9.2.2　 认证
#### 9.2.3　 授权
## 第10章 可观测性
### 10.1　 事件日志
#### 10.1.1　 输出
#### 10.1.2　 收集与缓冲
#### 10.1.3　 加工与聚合
#### 10.1.4　 存储与查询
### 10.2　 链路追踪
#### 10.2.1　 追踪与跨度
#### 10.2.2　 数据收集
#### 10.2.3　 追踪规范化
### 10.3　 聚合度量
#### 10.3.1　 指标收集
#### 10.3.2　 存储查询
#### 10.3.3　 监控预警
# 第四部分　不可变基础设施
## 第11章 虚拟化容器
### 11.1　 容器的崛起
#### 11.1.1　 隔离文件：chroot
#### 11.1.2　 隔离访问：名称空间
#### 11.1.3　 隔离资源：cgroups
#### 11.1.4　 封装系统：LXC
#### 11.1.5　 封装应用：Docker
#### 11.1.6　 封装集群：Kubernetes
### 11.2　 以容器构建系统
#### 11.2.1　 隔离与协作
#### 11.2.2　 韧性与弹性
### 11.3　 以应用为中心的封装
#### 11.3.1　 Kustomize
#### 11.3.2　 Helm与Chart
#### 11.3.3　 Operator与CRD
#### 11.3.4　 开放应用模型
## 第12章 容器间网络
### 12.1　 Linux网络虚拟化
#### 12.1.1　 网络通信模型
#### 12.1.2　 干预网络通信
#### 12.1.3　 虚拟化网络设备
#### 12.1.4　 容器间通信
### 12.2　 容器网络与生态
#### 12.2.1　 CNM与CNI
#### 12.2.2　 CNM到CNI
#### 12.2.3　 网络插件生态
## 第13章 持久化存储
### 13.1　 Kubernetes存储设计
#### 13.1.1　 Mount和Volume
#### 13.1.2　 静态存储分配
#### 13.1.3　 动态存储分配
### 13.2　 容器存储与生态
#### 13.2.1　 Kubernetes存储架构
#### 13.2.2　 FlexVolume与CSI
#### 13.2.3　 从In-Tree到Out-of-Tree
#### 13.2.4　 容器插件生态
## 第14章 资源与调度
### 14.1　 资源模型
### 14.2　 服务质量与优先级
### 14.3　 驱逐机制
### 14.4　 默认调度器
## 第15章 服务网格
### 15.1　 透明通信的涅槃
#### 15.1.1　 通信成本
#### 15.1.2　 数据平面
#### 15.1.3　 控制平面
### 15.2　 服务网格与生态
#### 15.2.1　 服务网格接口
#### 15.2.2　 通用数据平面API
#### 15.2.3　 服务网格生态
# 第五部分　技术方法论
## 第16章 向微服务迈进
### 16.1　 目的：微服务的驱动力
### 16.2　 前提：微服务需要的条件
### 16.3　 边界：微服务的粒度
### 16.4　 治理：理解系统复杂性
#### 16.4.1　 静态的治理
#### 16.4.2　 发展的治理
### 附录A　技术演示工程实践383
### 附录B　部署Kubernetes集群402