前言
第一部分　演进中的架构
第1章　服务架构演进史2
1.1　原始分布式时代2
1.2　单体系统时代5
1.3　SOA时代8
1.4　微服务时代12
1.5　后微服务时代16
1.6　无服务时代19
第二部分　架构师的视角
第2章　访问远程服务24
2.1　远程服务调用24
2.1.1　进程间通信24
2.1.2　通信的成本26
2.1.3　三个基本问题28
2.1.4　统一的RPC30
2.1.5　分裂的RPC32
2.2　REST设计风格34
2.2.1　理解REST35
2.2.2　RESTful的系统37
2.2.3　RMM41
2.2.4　不足与争议45
第3章　事务处理48
3.1　本地事务49
3.1.1　实现原子性和持久性50
3.1.2　实现隔离性54
3.2　全局事务57
3.3　共享事务62
3.4　分布式事务64
3.4.1　CAP与ACID64
3.4.2　可靠事件队列67
3.4.3　TCC事务69
3.4.4　SAGA事务72
第4章　透明多级分流系统75
4.1　客户端缓存76
4.1.1　强制缓存77
4.1.2　协商缓存79
4.2　域名解析81
4.3　传输链路83
4.3.1　连接数优化84
4.3.2　传输压缩88
4.3.3　快速UDP网络连接90
4.4　内容分发网络92
4.4.1　路由解析92
4.4.2　内容分发95
4.4.3　CDN应用96
4.5　负载均衡97
4.5.1　数据链路层负载均衡99
4.5.2　网络层负载均衡101
4.5.3　应用层负载均衡104
4.5.4　均衡策略与实现106
4.6　服务端缓存107
4.6.1　缓存属性108
4.6.2　缓存风险117
第5章　架构安全性120
5.1　认证121
5.1.1　认证的标准121
5.1.2　认证的实现128
5.2　授权129
5.2.1　RBAC130
5.2.2　OAuth 2133
5.3　凭证140
5.3.1　Cookie-Session140
5.3.2　JWT142
5.4　保密147
5.4.1　保密的强度147
5.4.2　客户端加密148
5.4.3　密码存储和验证149
5.5　传输151
5.5.1　摘要、加密与签名151
5.5.2　数字证书154
5.5.3　传输安全层157
5.6　验证160
第三部分　分布式的基石
第6章　分布式共识166
6.1　Paxos168
6.1.1　Paxos的诞生169
6.1.2　算法流程169
6.1.3　工作实例172
6.2　Multi Paxos174
6.3　Gossip协议178
第7章　从类库到服务180
7.1　服务发现180
7.1.1　服务发现的意义181
7.1.2　可用与可靠182
7.1.3　注册中心实现185
7.2　网关路由186
7.2.1　网关的职责186
7.2.2　网络I/O模型188
7.2.3　BFF网关190
7.3　客户端负载均衡191
7.3.1　客户端负载均衡器193
7.3.2　代理负载均衡器194
7.3.3　地域与区域196
第8章　流量治理198
8.1　服务容错198
8.1.1　容错策略199
8.1.2　容错设计模式201
8.2　流量控制209
8.2.1　流量统计指标210
8.2.2　限流设计模式211
8.2.3　分布式限流215
第9章　可靠通信217
9.1　零信任网络217
9.1.1　零信任安全模型的特征218
9.1.2　Google的实践探索220
9.2　服务安全222
9.2.1　建立信任222
9.2.2　认证223
9.2.3　授权227
第10章　可观测性230
10.1　事件日志233
10.1.1　输出233
10.1.2　收集与缓冲235
10.1.3　加工与聚合236
10.1.4　存储与查询237
10.2　链路追踪239
10.2.1　追踪与跨度239
10.2.2　数据收集240
10.2.3　追踪规范化243
10.3　聚合度量244
10.3.1　指标收集245
10.3.2　存储查询248
10.3.3　监控预警250
第四部分　不可变基础设施
第11章　虚拟化容器254
11.1　容器的崛起256
11.1.1　隔离文件：chroot256
11.1.2　隔离访问：名称空间257
11.1.3　隔离资源：cgroups258
11.1.4　封装系统：LXC259
11.1.5　封装应用：Docker260
11.1.6　封装集群：Kubernetes263
11.2　以容器构建系统266
11.2.1　隔离与协作266
11.2.2　韧性与弹性271
11.3　以应用为中心的封装275
11.3.1　Kustomize276
11.3.2　Helm与Chart277
11.3.3　Operator与CRD279
11.3.4　开放应用模型284
第12章　容器间网络288
12.1　Linux网络虚拟化288
12.1.1　网络通信模型289
12.1.2　干预网络通信291
12.1.3　虚拟化网络设备294
12.1.4　容器间通信304
12.2　容器网络与生态306
12.2.1　CNM与CNI306
12.2.2　CNM到CNI308
12.2.3　网络插件生态310
第13章　持久化存储314
13.1　Kubernetes存储设计314
13.1.1　Mount和Volume316
13.1.2　静态存储分配318
13.1.3　动态存储分配322
13.2　容器存储与生态325
13.2.1　Kubernetes存储架构325
13.2.2　FlexVolume与CSI327
13.2.3　从In-Tree到Out-of-Tree329
13.2.4　容器插件生态331
第14章　资源与调度336
14.1　资源模型336
14.2　服务质量与优先级337
14.3　驱逐机制340
14.4　默认调度器342
第15章　服务网格346
15.1　透明通信的涅槃347
15.1.1　通信成本347
15.1.2　数据平面352
15.1.3　控制平面358
15.2　服务网格与生态360
15.2.1　服务网格接口361
15.2.2　通用数据平面API363
15.2.3　服务网格生态364
第五部分　技术方法论
第16章　向微服务迈进368
16.1　目的：微服务的驱动力369
16.2　前提：微服务需要的条件371
16.3　边界：微服务的粒度375
16.4　治理：理解系统复杂性377
16.4.1　静态的治理378
16.4.2　发展的治理380
附录A　技术演示工程实践383
附录B　部署Kubernetes集群402