第1章  CPU硬件原理        1
1.1  CPU的生产过程        2
1.2  个人电脑CPU硬件简介        3
1.2.1  个人电脑CPU代际简介        4
1.2.2  个人电脑CPU内部架构        6
1.3  服务器CPU硬件简介        7
1.3.1  服务器CPU代际简介        8
1.3.2  服务器CPU内部架构        9
1.3.3  服务器CPU片内总线        10
1.3.4  服务器CPU片间互联        12
1.4  CPU核原理        15
1.4.1  CPU核内部结构        15
1.4.2  CPU的工作频率        19
1.4.3  物理核与逻辑核        20
1.4.4  CPU的L1L2L3缓存查看        22
1.4.5  CPU的TLB缓存查看        25
1.5  本章总结        28

第2章  内存硬件原理        30
2.1  CPU对内存的硬件支持        31
2.1.1  CPU的内存控制器        31
2.1.2  CPU支持的内存代际        32
2.1.3  CPU支持的内存模块规格         34
2.1.4  服务器CPU支持的ECC内存        36
2.2  内存硬件内部结构        44
2.2.1  内存的Rank与位宽        45
2.2.2  内存Chip内部构成        45
2.2.3  服务器内存颗粒构成        47
2.3  内存IO原理        48
2.3.1  内存延迟        48
2.3.2  内存IO过程        49
2.3.3  内存Burst IO        51
2.4  存储性能测试        52
2.4.1  延时测试        52
2.4.2  带宽测试        55
2.5  本章总结        57

第3章  进程、线程的对比        58
3.1  进程、线程定义        59
3.1.1  进程、线程状态        61
3.1.2  进程ID与线程ID        62
3.1.3  进程树关系        63
3.1.4  进程调度优先级        63
3.1.5  进程地址空间        64
3.1.6  进程文件系统信息（当前目录等）        65
3.1.7  进程打开的文件信息        66
3.1.8  命名空间        67
3.2  进程的创建        69
3.2.1  Nginx使用fork创建worker        69
3.2.2  fork系统调用原理        70
3.2.3  本节小结        84
3.3  线程的创建        85
3.3.1  线程与进程创建的异同        87
3.3.2  fork创建线程的详细过程        88
3.4  进程与线程的异同汇总        93
3.5  本章总结        94

第4章  进程加载启动原理        96
4.1  可执行文件格式        97
4.1.1  ELF文件头        98
4.1.2  Program Header Table        100
4.1.3  Section Header Table        102
4.1.4  各种Section        103
4.1.5  入口进一步查看        104
4.2  shell启动用户进程        106
4.3  Linux的可执行文件加载器        108
4.4  execve加载用户程序        110
4.4.1  alloc_bprm初始化linux_binprm对象        112
4.4.2  bprm_execve执行加载        114
4.5  ELF文件加载过程        115
4.5.1  读取ELF文件头        116
4.5.2  读取Program Header        117
4.5.3  清空父进程继承来的资源        118
4.5.4  执行Segment加载        120
4.5.5  数据内存申请和堆初始化        122
4.5.6  跳转到程序入口执行        123
4.6  本章总结        125

第5章  系统物理内存初始化        127
5.1  固件介绍        128
5.2  物理内存安装检测        129
5.3  初期memblock内存分配器        133
5.3.1  memblock内存分配器的创建        133
5.3.2  向memblock分配器申请内存        136
5.4  NUMA信息感知        139
5.4.1  非一致性内存访问原因        139
5.4.2  Linux获取NUMA信息        140
5.5  物理页管理之伙伴系统        143
5.5.1  伙伴系统相关数据结构        143
5.5.2  伙伴系统管理空闲页面        145
5.5.3  memblock向伙伴系统交接物理内存        148
5.6  本章总结        149

第6章  进程如何使用内存        153
6.1  虚拟内存和物理页        154
6.1.1  虚拟地址空间        154
6.1.2  缺页中断        157
6.2  虚拟内存使用方式        162
6.2.1  进程启动时对虚拟内存的使用        162
6.2.2  mmap        166
6.2.3  sbrk和brk        168
6.3  进程栈内存的使用        170
6.3.1  进程栈的初始化        170
6.3.2  栈的自动增长        172
6.3.3  进程栈总结        176
6.4  线程栈是如何使用内存的        176
6.4.1  glibc线程对象        178
6.4.2  确定栈空间大小        178
6.4.3  申请用户栈        180
6.4.4  创建线程        182
6.4.5  线程栈小结        183
6.5  进程堆内存管理        183
6.5.1  ptmalloc内存分配器定义        184
6.5.2  malloc内存分配过程        190
6.6  本章总结        192

第7章  进程调度器        196
7.1  Linux进程调度发展简史        197
7.1.1  O(n)调度发展过程        197
7.1.2  Linux 2.5 O(1)调度器        201
7.1.3  完全公平调度器诞生        205
7.2  Linux调度器定义        205
7.2.1  实时调度器        208
7.2.2  完全公平调度器        209
7.3  进程的任务队列选择        211
7.3.1  新进程创建时加入        212
7.3.2  老进程唤醒时加入        220
7.4  调度时机        221
7.4.1  调度节拍        221
7.4.2  真正的调度        232
7.5  任务切换开销实测        234
7.5.1  进程切换开销        235
7.5.2  线程切换开销        237
7.6  Linux调度器相关命令        238
7.6.1  调度策略        238
7.6.2  nice值设置        239
7.6.3  taskset命令        241
7.7  本章总结        242

第8章  性能统计原理        246
8.1  负载        247
8.1.1  理解负载查看过程        247
8.1.2  内核负载计算过程        249
8.1.3  平均负载和CPU消耗的关系        254
8.1.4  负载计算整体流程        256
8.2  CPU利用率        256
8.2.1  方案思考        257
8.2.2  top命令使用的数据在哪里        259
8.2.3  统计数据是怎么来的        262
8.2.4  CPU利用率统计流程        266
8.3  指令统计        268
8.4  本章总结        270

第9章  用户态协程        274
9.1  Go的GMP原理        275
9.1.1  Go中的线程        276
9.1.2  Go中的协程        277
9.1.3  Go中的虚拟处理器        278
9.2  Go程序启动过程        280
9.2.1  寻找执行入口        281
9.2.2  执行入口分析        282
9.2.3  main函数真正运行        290
9.3  协程的栈内存        292
9.3.1  回忆进程栈和glibc 线程栈        292
9.3.2  Go的线程栈与协程栈        293
9.3.3  Go协程栈的扩张        296
9.4  使用协程封装epoll        299
9.4.1  Go net包使用方式        300
9.4.2  Listen底层过程        301
9.4.3  Accept过程        305
9.4.4  Read和Write内部过程        310
9.4.5  Go唤醒协程        312
9.5  协程切换性能测试        314
9.6  本章总结        316

第10章  容器化技术        318
10.1  容器发展过程        319
10.1.1  虚拟机时代        319
10.1.2  容器化技术        320
10.2  PID命名空间        326
10.2.1  默认命名空间        327
10.2.2  新PID命名空间创建        330
10.2.3  在命名空间中申请pid        334
10.2.4  容器进程pid查看        337
10.3  本章总结        339

第11章  容器的CPU资源限制        340
11.1  CPU cgroup的创建原理        341
11.1.1  使用cgroupfs创建cgroup        341
11.1.2  内核中cgroup的相关定义        344
11.1.3  创建cgroup对象原理        349
11.1.4  将进程PID写进cgroup        351
11.2  容器CPU权重分配实现        354
11.2.1  容器CPU权重设置        354
11.2.2  容器CPU权重分配实现        355
11.3  容器CPU限制分配实现        358
11.3.1  设置CPU限制        358
11.3.2  设置CPU限制底层原理        360
11.3.3  进程CPU带宽控制过程        362
11.3.4  进程的可运行时间的分配        368
11.3.5  容器CPU性能        372
11.4  K8s中的limits与requests        375
11.5  容器中的CPU利用率        377
11.5.1  获取容器CPU利用率的思路        377
11.5.2  cgroup v1 CPU 利用率统计原理        381
11.5.3  cgroup v2 CPU利用率统计原理        385
11.6  本章总结        391

第12章  容器的内存资源限制        394
12.1  内存cgroup的创建原理        395
12.1.1  内存cgroup定义        395
12.1.2  创建内存cgroup        395
12.1.3  内存cgroup中的接口文件        397
12.2  设置内存cgroup内存限制        397
12.3  容器物理内存的分配        399
12.3.1  记账过程        401
12.3.2  容器内存超出限制时的处理        402
12.3.3  详细记账        402
12.4  容器内存用量查看        403
12.4.1  总开销观察        403
12.4.2  详细开销观察        404
12.5  动手模拟容器内存限制实验        405
12.6  本章总结        409

第13章  调用原理及性能        411
13.1  函数调用        412
13.1.1  C语言函数工作原理        412
13.1.2  Go语言函数工作原理        414
13.1.3  函数开销实测        415
13.2  系统调用        416
13.2.1  系统调用内部原理        417
13.2.2  系统调用性能实测        418
13.3  RPC调用        420
13.4  本章总结        423

第14章  性能观测技术原理        424
14.1  性能观测技术概览        425
14.2  内核伪文件系统        429
14.2.1  procfs        429
14.2.2  sysfs        431
14.3  硬件和软件事件        431
14.3.1  硬件事件        431
14.3.2  软件事件        438
14.4  火焰图原理        442
14.4.1  perf采样原理        444
14.4.2  FlameGraph工作过程        446
14.5  内核跟踪技术原理        448
14.5.1  静态跟踪        448
14.5.2  kprobes动态跟踪         455
14.6  观测工具介绍        459
14.6.1  perf工具介绍        459
14.6.2  Kubernetes统计上报        467
14.7  本章总结        468

第15章  CPU性能观测方法        469
15.1  CPU利用率        470
15.2  热点火焰图        479
15.3  系统调用        480
15.4  调度器运行观测        481
15.4.1  负载        482
15.4.2  任务上下文切换次数        483
15.4.3  任务迁移次数        486
15.4.4  调度器延迟        486
15.5  虚拟内存开销        487
15.6  网络协议栈开销        488
15.7  硬件指令运行效率        493
15.7.1  CPI和IPC        494
15.7.2  Cache Miss        496
15.8  本章总结        498

第16章  程序CPU性能优化        500
16.1  应用层优化        501
16.1.1  热点函数查找        501
16.1.2  减少不必要的业务逻辑处理        502
16.1.3  算法优化        502
16.1.4  反微服务        504
16.1.5  内存对齐        506
16.1.6  缓存友好性的代码        507
16.2  编程语言及框架优化        509
16.2.1  编程语言性能差异        509
16.2.2  网络IO编程模型        510
16.2.3  内存分配器        511
16.3  内核调优        513
16.3.1  减少系统调用        513
16.3.2  虚拟内存优化        513
16.3.3  调度器优化        514
16.3.4  网络协议栈优化        520
16.4  基础设施优化        522
16.4.1  CPU硬件提升        522
16.4.2  开启睿频        523
16.4.3  关闭超线程        524
16.4.4  硬件卸载        524
16.4.5  容器云部署        524
16.5  性能优化案例        525
16.5.1  内核中的likely和unlikely        525
16.5.2  PHP7内存性能优化        527
16.5.3  新闻种子快速匹配        530
16.5.4  网址安全服务性能提升        531
16.5.5  CloudFlare接入层性能提升        533
16.6  本章总结        534