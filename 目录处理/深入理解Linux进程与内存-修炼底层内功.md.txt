## 第1章 CPU硬件原理
### 1.1   CPU的生产过程
### 1.2   个人电脑CPU硬件简介
#### 1.2.1   个人电脑CPU代际简介
#### 1.2.2   个人电脑CPU内部架构
### 1.3   服务器CPU硬件简介
#### 1.3.1   服务器CPU代际简介
#### 1.3.2   服务器CPU内部架构
#### 1.3.3   服务器CPU片内总线
#### 1.3.4   服务器CPU片间互联
### 1.4   CPU核原理
#### 1.4.1   CPU核内部结构
#### 1.4.2   CPU的工作频率
#### 1.4.3   物理核与逻辑核
#### 1.4.4   CPU的L1L2L3缓存查看
#### 1.4.5   CPU的TLB缓存查看
### 1.5   本章总结
## 第2章 内存硬件原理
### 2.1   CPU对内存的硬件支持
#### 2.1.1   CPU的内存控制器
#### 2.1.2   CPU支持的内存代际
#### 2.1.3   CPU支持的内存模块规格
#### 2.1.4   服务器CPU支持的ECC内存
### 2.2   内存硬件内部结构
#### 2.2.1   内存的Rank与位宽
#### 2.2.2   内存Chip内部构成
#### 2.2.3   服务器内存颗粒构成
### 2.3   内存IO原理
#### 2.3.1   内存延迟
#### 2.3.2   内存IO过程
#### 2.3.3   内存Burst IO
### 2.4   存储性能测试
#### 2.4.1   延时测试
#### 2.4.2   带宽测试
### 2.5   本章总结
## 第3章 进程、线程的对比
### 3.1   进程、线程定义
#### 3.1.1   进程、线程状态
#### 3.1.2   进程ID与线程ID
#### 3.1.3   进程树关系
#### 3.1.4   进程调度优先级
#### 3.1.5   进程地址空间
#### 3.1.6   进程文件系统信息（当前目录等）
#### 3.1.7   进程打开的文件信息
#### 3.1.8   命名空间
### 3.2   进程的创建
#### 3.2.1   Nginx使用fork创建worker
#### 3.2.2   fork系统调用原理
#### 3.2.3   本节小结
### 3.3   线程的创建
#### 3.3.1   线程与进程创建的异同
#### 3.3.2   fork创建线程的详细过程
### 3.4   进程与线程的异同汇总
### 3.5   本章总结
## 第4章 进程加载启动原理
### 4.1   可执行文件格式
#### 4.1.1   ELF文件头
#### 4.1.2   Program Header Table
#### 4.1.3   Section Header Table
#### 4.1.4   各种Section
#### 4.1.5   入口进一步查看
### 4.2   shell启动用户进程
### 4.3   Linux的可执行文件加载器
### 4.4   execve加载用户程序
#### 4.4.1   alloc_bprm初始化linux_binprm对象
#### 4.4.2   bprm_execve执行加载
### 4.5   ELF文件加载过程
#### 4.5.1   读取ELF文件头
#### 4.5.2   读取Program Header
#### 4.5.3   清空父进程继承来的资源
#### 4.5.4   执行Segment加载
#### 4.5.5   数据内存申请和堆初始化
#### 4.5.6   跳转到程序入口执行
### 4.6   本章总结
## 第5章 系统物理内存初始化
### 5.1   固件介绍
### 5.2   物理内存安装检测
### 5.3   初期memblock内存分配器
#### 5.3.1   memblock内存分配器的创建
#### 5.3.2   向memblock分配器申请内存
### 5.4   NUMA信息感知
#### 5.4.1   非一致性内存访问原因
#### 5.4.2   Linux获取NUMA信息
### 5.5   物理页管理之伙伴系统
#### 5.5.1   伙伴系统相关数据结构
#### 5.5.2   伙伴系统管理空闲页面
#### 5.5.3   memblock向伙伴系统交接物理内存
### 5.6   本章总结
## 第6章 进程如何使用内存
### 6.1   虚拟内存和物理页
#### 6.1.1   虚拟地址空间
#### 6.1.2   缺页中断
### 6.2   虚拟内存使用方式
#### 6.2.1   进程启动时对虚拟内存的使用
#### 6.2.2   mmap
#### 6.2.3   sbrk和brk
### 6.3   进程栈内存的使用
#### 6.3.1   进程栈的初始化
#### 6.3.2   栈的自动增长
#### 6.3.3   进程栈总结
### 6.4   线程栈是如何使用内存的
#### 6.4.1   glibc线程对象
#### 6.4.2   确定栈空间大小
#### 6.4.3   申请用户栈
#### 6.4.4   创建线程
#### 6.4.5   线程栈小结
### 6.5   进程堆内存管理
#### 6.5.1   ptmalloc内存分配器定义
#### 6.5.2   malloc内存分配过程
### 6.6   本章总结
## 第7章 进程调度器
### 7.1   Linux进程调度发展简史
#### 7.1.1   O(n)调度发展过程
#### 7.1.2   Linux 2.5 O(1)调度器
#### 7.1.3   完全公平调度器诞生
### 7.2   Linux调度器定义
#### 7.2.1   实时调度器
#### 7.2.2   完全公平调度器
### 7.3   进程的任务队列选择
#### 7.3.1   新进程创建时加入
#### 7.3.2   老进程唤醒时加入
### 7.4   调度时机
#### 7.4.1   调度节拍
#### 7.4.2   真正的调度
### 7.5   任务切换开销实测
#### 7.5.1   进程切换开销
#### 7.5.2   线程切换开销
### 7.6   Linux调度器相关命令
#### 7.6.1   调度策略
#### 7.6.2   nice值设置
#### 7.6.3   taskset命令
### 7.7   本章总结
## 第8章 性能统计原理
### 8.1   负载
#### 8.1.1   理解负载查看过程
#### 8.1.2   内核负载计算过程
#### 8.1.3   平均负载和CPU消耗的关系
#### 8.1.4   负载计算整体流程
### 8.2   CPU利用率
#### 8.2.1   方案思考
#### 8.2.2   top命令使用的数据在哪里
#### 8.2.3   统计数据是怎么来的
#### 8.2.4   CPU利用率统计流程
### 8.3   指令统计
### 8.4   本章总结
## 第9章 用户态协程
### 9.1   Go的GMP原理
#### 9.1.1   Go中的线程
#### 9.1.2   Go中的协程
#### 9.1.3   Go中的虚拟处理器
### 9.2   Go程序启动过程
#### 9.2.1   寻找执行入口
#### 9.2.2   执行入口分析
#### 9.2.3   main函数真正运行
### 9.3   协程的栈内存
#### 9.3.1   回忆进程栈和glibc 线程栈
#### 9.3.2   Go的线程栈与协程栈
#### 9.3.3   Go协程栈的扩张
### 9.4   使用协程封装epoll
#### 9.4.1   Go net包使用方式
#### 9.4.2   Listen底层过程
#### 9.4.3   Accept过程
#### 9.4.4   Read和Write内部过程
#### 9.4.5   Go唤醒协程
### 9.5   协程切换性能测试
### 9.6   本章总结
## 第10章 容器化技术
### 10.1   容器发展过程
#### 10.1.1   虚拟机时代
#### 10.1.2   容器化技术
### 10.2   PID命名空间
#### 10.2.1   默认命名空间
#### 10.2.2   新PID命名空间创建
#### 10.2.3   在命名空间中申请pid
#### 10.2.4   容器进程pid查看
### 10.3   本章总结
## 第11章 容器的CPU资源限制
### 11.1   CPU cgroup的创建原理
#### 11.1.1   使用cgroupfs创建cgroup
#### 11.1.2   内核中cgroup的相关定义
#### 11.1.3   创建cgroup对象原理
#### 11.1.4   将进程PID写进cgroup
### 11.2   容器CPU权重分配实现
#### 11.2.1   容器CPU权重设置
#### 11.2.2   容器CPU权重分配实现
### 11.3   容器CPU限制分配实现
#### 11.3.1   设置CPU限制
#### 11.3.2   设置CPU限制底层原理
#### 11.3.3   进程CPU带宽控制过程
#### 11.3.4   进程的可运行时间的分配
#### 11.3.5   容器CPU性能
### 11.4   K8s中的limits与requests
### 11.5   容器中的CPU利用率
#### 11.5.1   获取容器CPU利用率的思路
#### 11.5.2   cgroup v1 CPU 利用率统计原理
#### 11.5.3   cgroup v2 CPU利用率统计原理
### 11.6   本章总结
## 第12章 容器的内存资源限制
### 12.1   内存cgroup的创建原理
#### 12.1.1   内存cgroup定义
#### 12.1.2   创建内存cgroup
#### 12.1.3   内存cgroup中的接口文件
### 12.2   设置内存cgroup内存限制
### 12.3   容器物理内存的分配
#### 12.3.1   记账过程
#### 12.3.2   容器内存超出限制时的处理
#### 12.3.3   详细记账
### 12.4   容器内存用量查看
#### 12.4.1   总开销观察
#### 12.4.2   详细开销观察
### 12.5   动手模拟容器内存限制实验
### 12.6   本章总结
## 第13章 调用原理及性能
### 13.1   函数调用
#### 13.1.1   C语言函数工作原理
#### 13.1.2   Go语言函数工作原理
#### 13.1.3   函数开销实测
### 13.2   系统调用
#### 13.2.1   系统调用内部原理
#### 13.2.2   系统调用性能实测
### 13.3   RPC调用
### 13.4   本章总结
## 第14章 性能观测技术原理
### 14.1   性能观测技术概览
### 14.2   内核伪文件系统
#### 14.2.1   procfs
#### 14.2.2   sysfs
### 14.3   硬件和软件事件
#### 14.3.1   硬件事件
#### 14.3.2   软件事件
### 14.4   火焰图原理
#### 14.4.1   perf采样原理
#### 14.4.2   FlameGraph工作过程
### 14.5   内核跟踪技术原理
#### 14.5.1   静态跟踪
#### 14.5.2   kprobes动态跟踪
### 14.6   观测工具介绍
#### 14.6.1   perf工具介绍
#### 14.6.2   Kubernetes统计上报
### 14.7   本章总结
## 第15章 CPU性能观测方法
### 15.1   CPU利用率
### 15.2   热点火焰图
### 15.3   系统调用
### 15.4   调度器运行观测
#### 15.4.1   负载
#### 15.4.2   任务上下文切换次数
#### 15.4.3   任务迁移次数
#### 15.4.4   调度器延迟
### 15.5   虚拟内存开销
### 15.6   网络协议栈开销
### 15.7   硬件指令运行效率
#### 15.7.1   CPI和IPC
#### 15.7.2   Cache Miss
### 15.8   本章总结
## 第16章 程序CPU性能优化
### 16.1   应用层优化
#### 16.1.1   热点函数查找
#### 16.1.2   减少不必要的业务逻辑处理
#### 16.1.3   算法优化
#### 16.1.4   反微服务
#### 16.1.5   内存对齐
#### 16.1.6   缓存友好性的代码
### 16.2   编程语言及框架优化
#### 16.2.1   编程语言性能差异
#### 16.2.2   网络IO编程模型
#### 16.2.3   内存分配器
### 16.3   内核调优
#### 16.3.1   减少系统调用
#### 16.3.2   虚拟内存优化
#### 16.3.3   调度器优化
#### 16.3.4   网络协议栈优化
### 16.4   基础设施优化
#### 16.4.1   CPU硬件提升
#### 16.4.2   开启睿频
#### 16.4.3   关闭超线程
#### 16.4.4   硬件卸载
#### 16.4.5   容器云部署
### 16.5   性能优化案例
#### 16.5.1   内核中的likely和unlikely
#### 16.5.2   PHP7内存性能优化
#### 16.5.3   新闻种子快速匹配
#### 16.5.4   网址安全服务性能提升
#### 16.5.5   CloudFlare接入层性能提升
### 16.6   本章总结